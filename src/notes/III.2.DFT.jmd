## III.2 Discrete Fourier Transform


In the last lecture we explored using the trapezium rule for approximating Fourier coefficients.
This is a linear map from function values to coefficients and thus can be reinterpreted as
a matrix-vector product, called the the Discrete Fourier Transform. It turns out the matrix
is unitary which leads to important properties including interpolation. Finally, we discuss how a clever
way of decomposing the DFT leads to a fast way of applying and inverting it, which is one of the
most influencial algorithms of the 20th century: the Fast Fourier Transform.


1. The Discrete Fourier Transform (DFT): We discuss the map from values to approximate Fourier coefficients, and back.
2. Interpolation: We show that the approximate Fourier expansion _exactly_ interpolates the values at the sample grid.
3. The Fast Fourier Transform (FFT): We discuss how the DFT can be applied in $O(n \log n)$ operations.

## 1. The Discrete Fourier transform

**Definition 1 (DFT)**
The _Discrete Fourier Transform (DFT)_ is defined as:
$$
\begin{align*}
Q_n &:= {1 \over \sqrt{n}} \begin{bmatrix} 1 & 1 & 1&  â‹¯ & 1 \\
                                    1 & {\rm e}^{-{\rm i} Î¸_1} & {\rm e}^{-{\rm i} Î¸_2} & â‹¯ & {\rm e}^{-{\rm i} Î¸_{n-1}} \\
                                    1 & {\rm e}^{-{\rm i} 2 Î¸_1} & {\rm e}^{-{\rm i} 2 Î¸_2} & â‹¯ & {\rm e}^{-{\rm i} 2Î¸_{n-1}} \\
                                    â‹® & â‹® & â‹® & â‹± & â‹® \\
                                    1 & {\rm e}^{-{\rm i} (n-1) Î¸_1} & {\rm e}^{-{\rm i} (n-1) Î¸_2} & â‹¯ & {\rm e}^{-{\rm i} (n-1) Î¸_{n-1}}
\end{bmatrix} \\
&= {1 \over \sqrt{n}} \begin{bmatrix} 1 & 1 & 1&  â‹¯ & 1 \\
                                    1 & Ï‰^{-1} & Ï‰^{-2} & â‹¯ & Ï‰^{-(n-1)}\\
                                    1 & Ï‰^{-2} & Ï‰^{-4} & â‹¯ & Ï‰^{-2(n-1)}\\
                                    â‹® & â‹® & â‹® & â‹± & â‹® \\
                                    1 & Ï‰^{-(n-1)} & Ï‰^{-2(n-1)} & â‹¯ & Ï‰^{-(n-1)^2}
\end{bmatrix}
\end{align*}
$$
for the $n$-th root of unity $Ï‰ = {\rm e}^{2Ï€{\rm i}/n}$. Note that
$$
\begin{align*}
Q_n^â‹† &= {1 \over \sqrt{n}} \begin{bmatrix}
1 & 1 & 1&  â‹¯ & 1 \\
1 & {\rm e}^{{\rm i} Î¸_1} & {\rm e}^{{\rm i} 2 Î¸_1} & â‹¯ & {\rm e}^{{\rm i} (n-1) Î¸_1} \\
1 &  {\rm e}^{{\rm i} Î¸_2}  & {\rm e}^{{\rm i} 2 Î¸_2} & â‹¯ & {\rm e}^{{\rm i} (n-1)Î¸_2} \\
â‹® & â‹® & â‹® & â‹± & â‹® \\
1 & {\rm e}^{{\rm i} Î¸_{n-1}} & {\rm e}^{{\rm i} 2 Î¸_{n-1}} & â‹¯ & {\rm e}^{{\rm i} (n-1) Î¸_{n-1}}
\end{bmatrix} \\
&= {1 \over \sqrt{n}} \begin{bmatrix}
1 & 1 & 1&  â‹¯ & 1 \\
1 & Ï‰^{1} & Ï‰^{2} & â‹¯ & Ï‰^{(n-1)}\\
1 & Ï‰^{2} & Ï‰^{4} & â‹¯ & Ï‰^{2(n-1)}\\
â‹® & â‹® & â‹® & â‹± & â‹® \\
1 & Ï‰^{(n-1)} & Ï‰^{2(n-1)} & â‹¯ & Ï‰^{(n-1)^2}
\end{bmatrix}
\end{align*}
$$

Note that
$$
\underbrace{\begin{bmatrix} fÌ‚_0^n \\ â‹® \\ fÌ‚_{n-1}^n \end{bmatrix}}_{ğŸÌ‚â¿} = 
{1 \over \sqrt{n}} Q_n \underbrace{\begin{bmatrix} f(Î¸_0) \\ â‹® \\ f(Î¸_{n-1}) \end{bmatrix}}_{ğŸâ¿}
$$

The choice of normalisation constant is motivated by the following:

**Proposition 1 (DFT is Unitary)** $Q_n âˆˆ U(n)$, that is, $Q_n^â‹† Q_n = Q_n Q_n^â‹† = I$.

**Proof**
$$
Q_n Q_n^â‹†  = \begin{bmatrix} Î£_n[1] & Î£_n[{\rm e}^{{\rm i} Î¸}] & â‹¯ & Î£_n[{\rm e}^{{\rm i} (n-1) Î¸}] \\
                            Î£_n[{\rm e}^{-{\rm i} Î¸}] & Î£_n[1] & â‹¯ & Î£_n[{\rm e}^{{\rm i} (n-2) Î¸}] \\
                            â‹® & â‹® & â‹± & â‹® \\
                            Î£_n[{\rm e}^{-{\rm i}(n-1) Î¸}] & Î£_n[{\rm e}^{-{\rm i}(n-2) Î¸}] & â‹¯ & Î£_n[1]
                            \end{bmatrix} = I
$$
âˆ

In other words, $Q_n$ is easily inverted and we also have a map from discrete Fourier coefficients back to values:
$$
\sqrt{n} Q_n^â‹† ğŸÌ‚â¿ = ğŸâ¿
$$

## 2. Interpolation

We investigated briefly interpolation and least squares using polynomials at evenly spaced points, observing that
there were issues with stability. We now show that the DFT actually gives coefficients that interpolate using Fourier
expansions. As the DFT is a unitary matrix its (2-norm) condition number is 1, hence this is a stable process. Thus we arrive
at the main result:

**Corollary 1 (Interpolation)**
$$
f_n(Î¸) := âˆ‘_{k=0}^{n-1} fÌ‚_k^n {\rm e}^{{\rm i} k Î¸}
$$
interpolates $f$ at $Î¸_j$:
$$
f_n(Î¸_j) = f(Î¸_j)
$$

**Proof**
We have
$$
f_n(Î¸_j) = âˆ‘_{k=0}^{n-1} fÌ‚_k^n {\rm e}^{{\rm i} k Î¸_j} = \sqrt n ğ_j^âŠ¤ Q_n^â‹† ğŸÌ‚â¿ = ğ_j^âŠ¤ Q_n^â‹† Q_n ğŸâ¿ = f(Î¸_j).
$$

âˆ


We will leave extending this result to the general non-Taylor case to the problem sheet. Note that regardless of choice of coefficients
we interpolate provided we have $n$ consecutive coefficients, though some interpolations are better than others:

```julia
using Plots, LinearAlgebra


# evaluates f_n at a point
function finitefourier(ğŸÌ‚â‚™, Î¸)
    m = n Ã· 2 # use coefficients between -m:m
    ret = 0.0 + 0.0im # coefficients are complex so we need complex arithmetic
    for k = 0:m
        ret += ğŸÌ‚â‚™[k+1] * exp(im*k*Î¸)
    end
    for k = -m:-1
        ret += ğŸÌ‚â‚™[end+k+1] * exp(im*k*Î¸)
    end
    ret
end

function finitetaylor(ğŸÌ‚â‚™, Î¸)
    ret = 0.0 + 0.0im # coefficients are complex so we need complex arithmetic
    for k = 0:n-1
        ret += ğŸÌ‚â‚™[k+1] * exp(im*k*Î¸)
    end
    ret
end


f = Î¸ -> exp(cos(Î¸))
n = 7
Î¸ = range(0,2Ï€; length=n+1)[1:end-1] # Î¸_0, â€¦,Î¸_{n-1}, dropping Î¸_n == 2Ï€
Qâ‚™ = 1/sqrt(n) * [exp(-im*(k-1)*Î¸[j]) for k = 1:n, j=1:n]
ğŸÌ‚â‚™ = 1/sqrt(n) * Qâ‚™ * f.(Î¸)


fâ‚™ = Î¸ -> finitefourier(ğŸÌ‚â‚™, Î¸)
tâ‚™ = Î¸ -> finitetaylor(ğŸÌ‚â‚™, Î¸)

g = range(0, 2Ï€; length=1000) # plotting grid
plot(g, f.(g); label="function", legend=:bottomright)
plot!(g, real.(fâ‚™.(g)); label="Fourier")
plot!(g, real.(tâ‚™.(g)); label="Taylor")
scatter!(Î¸, f.(Î¸); label="samples")
```

We now demonstrate the relationship of Taylor and Fourier coefficients
and their discrete approximations for some examples:

**Example 1** Consider the function
$$
f(Î¸) = {2 \over 2 - {\rm e}^{{\rm i} Î¸}}
$$
Under the change of variables $z = {\rm e}^{{\rm i} Î¸}$ we know for
$z$ on the unit circle this becomes (using the geometric series with $z/2$)
$$
{2 \over 2-z} = âˆ‘_{k=0}^âˆ {z^k \over 2^k}
$$
i.e., $fÌ‚_k = 1/2^k$ which is absolutely summable:
$$
âˆ‘_{k=0}^âˆ |fÌ‚_k| = f(0) = 2.
$$
If we use an $n$ point discretisation we get (using the geoemtric series with $2^{-n}$)
$$
fÌ‚_k^n = fÌ‚_k + fÌ‚_{k+n} + fÌ‚_{k+n} + â‹¯ = âˆ‘_{p=0}^âˆ {1 \over 2^{k+pn}} = {2^{n-k} \over 2^n - 1}
$$
We can verify this numerically:
```julia
f = Î¸ -> 2/(2 - exp(im*Î¸))
n = 7
Î¸ = range(0,2Ï€; length=n+1)[1:end-1] # Î¸_0, â€¦,Î¸_{n-1}, dropping Î¸_n == 2Ï€
Qâ‚™ = 1/sqrt(n) * [exp(-im*(k-1)*Î¸[j]) for k = 1:n, j=1:n]

Qâ‚™/sqrt(n)*f.(Î¸) â‰ˆ 2 .^ (n .- (0:n-1)) / (2^n-1)
```

**Example 2** Define the following infinite sum (which has no name apparently,
according to Mathematica):
$$
S_n(k) := âˆ‘_{p=0}^âˆ {1 \over (k+pn)!}
$$
We can use the DFT to compute $S_n(0), â€¦, S_n(n-1)$.
Consider
$$
f(Î¸) = \exp({\rm e}^{{\rm i} Î¸}) = âˆ‘_{k=0}^âˆ {{\rm e}^{{\rm i} k Î¸} \over k!}
$$
where we know the Fourier coefficients from the Taylor series of ${\rm e}^z$. 
The discrete Fourier coefficients satisfy for $0 â‰¤Â k â‰¤Â n-1$:
$$
fÌ‚_k^n = fÌ‚_k + fÌ‚_{k+n} + fÌ‚_{k+2n} + â‹¯ = S_n(k)
$$
Thus we have
$$
\begin{bmatrix}
S_n(0) \\ 
â‹® \\
S_n(n-1)
\end{bmatrix} = {1 \over \sqrt{n}} Q_n \begin{bmatrix} 1 \\
                                \exp({\rm e}^{2{\rm i} Ï€/n}) \\
                                â‹® \\
                                \exp({\rm e}^{2{\rm i} (n-1) Ï€/n}) \end{bmatrix}
$$




## 3. Fast Fourier Transform (non-examinable)

Applying $Qâ‚™$ or its adjoint $Q_n^â‹†$ to a vector naively takes $O(n^2)$ operations.
Both can be reduced to $O(n \log n)$ using the celebrated _Fast Fourier Transform_ (FFT),
which is one of the [Top 10 Algorithms of the 20th Century](https://pi.math.cornell.edu/~web6140/)
(You won't believe number 7!).

The key observation is that hidden in $Q_{2n}$ are 2 copies of
$Q_n$. We will work with multiple $n$ we denote the $n$-th root as $Ï‰_n = \exp(2Ï€/n)$.
Note that we can relate a vector of powers of $Ï‰_{2n}$ to two copies of vectors of powers of $Ï‰_n$:
$$
\underbrace{\begin{bmatrix} 1 \\ Ï‰_{2n} \\ â‹® \\ Ï‰_{2n}^{2n-1} \end{bmatrix}}_{\vec{Ï‰}_{2n}} =
P_Ïƒ^âŠ¤ \begin{bmatrix} I_n \\ Ï‰_{2n} I_n \end{bmatrix} \underbrace{\begin{bmatrix} 1 \\ Ï‰_n \\ â‹® \\ Ï‰_n^{n-1} \end{bmatrix}}_{\vec{Ï‰}_n}
$$
where $Ïƒ$ has the Cauchy notation
$$
\begin{pmatrix}
1 & 2 & 3 & â‹¯ & n & n+1 & â‹¯ & 2n \\
1 & 3 & 5 & â‹¯ & 2n-1 & 2 & â‹¯ & 2n
\end{pmatrix}
$$
That is, $P_Ïƒ$ is the following matrix which takes the even entries
and places them in the first $n$ entries and the odd entries in the
last $n$ entries:
```julia
n = 4
Ïƒ = [1:2:2n-1; 2:2:2n]
P_Ïƒ = I(2n)[Ïƒ,:]
```
and so $P_Ïƒ^âŠ¤$ reverses the process.
Thus we have
$$
\begin{align*}
Q_{2n}^â‹† &= {1 \over \sqrt{2n}} \begin{bmatrix} ğŸ_{2n} | \vec{Ï‰}_{2n} | \vec{Ï‰}_{2n}^2 | â‹¯ | \vec{Ï‰}_{2n}^{2n-1} \end{bmatrix}
= {1 \over \sqrt{2n}} P_Ïƒ^âŠ¤ \begin{bmatrix} ğŸ_{n} &   \vec{Ï‰}_n        & \vec{Ï‰}_n^2          & â‹¯ & \vec{Ï‰}_n^{n-1}          & \vec{Ï‰}_n^n  & â‹¯ & \vec{Ï‰}_n^{2n-1}  \\
                        ğŸ_{n} & Ï‰_{2n} \vec{Ï‰}_n & Ï‰_{2n}^2 \vec{Ï‰}_n^2 & â‹¯ & Ï‰_{2n}^{n-1} \vec{Ï‰}_n^{n-1} & Ï‰_{2n}^n \vec{Ï‰}_n^n  & â‹¯ & Ï‰_{2n}^{2n-1} \vec{Ï‰}_n^{2n-1}
\end{bmatrix} \\
&= {1 \over \sqrt{2}} P_Ïƒ^âŠ¤ \begin{bmatrix} Q_n^â‹† & Q_n^â‹† \\
                                     Q_n^â‹† D_n & -Q_n^â‹† D_n
                                     \end{bmatrix} =
                                     {1 \over \sqrt{2}}P_Ïƒ^âŠ¤ \begin{bmatrix} Q_n^â‹† \\ &Q_n^â‹† \end{bmatrix} \begin{bmatrix} I_n & I_n \\ D_n & -D_n \end{bmatrix}
\end{align*}
$$
In other words, we reduced the DFT to two DFTs applied to vectors of half the dimension.

We can see this formula in code:
```julia
function fftmatrix(n)
    Î¸ = range(0,2Ï€; length=n+1)[1:end-1] # Î¸_0, â€¦,Î¸_{n-1}, dropping Î¸_n == 2Ï€
    [exp(-im*(k-1)*Î¸[j]) for k = 1:n, j=1:n]/sqrt(n)
end

Qâ‚‚â‚™ = fftmatrix(2n)
Qâ‚™ = fftmatrix(n)
Dâ‚™ = Diagonal([exp(im*k*Ï€/n) for k=0:n-1])
(P_Ïƒ'*[Qâ‚™' Qâ‚™'; Qâ‚™'*Dâ‚™ -Qâ‚™'*Dâ‚™])[1:n,1:n] â‰ˆ sqrt(2)Qâ‚‚â‚™'[1:n,1:n]
```


Now assume $n = 2^q$ so that $\log_2 n = q$. To see that we get $O(n \log n) = O(n q)$ operations we need to count the operations.
Assume that applying $F_n$ takes $â‰¤3n q$ additions and multiplications. The first $n$ rows takes $n$ additions. The last $n$ has $n$ multiplications and $n$ additions.
Thus we have $6nq + 3n â‰¤ 6n(q+1) = 3 (2n) \log_2(2n)$ additions/multiplications, showing by induction that we have $O(n \log n)$ operations.



**Remark** The FFTW.jl package wraps the FFTW (Fastest Fourier Transform in the West) library,
which is a highly optimised implementation
of the FFT that also works well even when $n$ is not a power of 2.
(As an aside, the creator of FFTW [Steven Johnson](https://math.mit.edu/~stevenj/) is now a
Julia contributor and user.)
 Here we approximate $\exp(\cos(Î¸-0.1))$ using
31 nodes:
```julia
using FFTW
f = Î¸ -> exp(cos(Î¸-0.1))
n = 31
m = nÃ·2
# evenly spaced points from 0:2Ï€, dropping last node
Î¸ = range(0, 2Ï€; length=n+1)[1:end-1]

# fft returns discrete Fourier coefficients n*[fÌ‚â¿_0, â€¦, fÌ‚â¿_(n-1)]
fc = fft(f.(Î¸))/n

# We reorder using [fÌ‚â¿_(-m), â€¦, fÌ‚â¿_(-1)] == [fÌ‚â¿_(n-m), â€¦, fÌ‚â¿_(n-1)]
#  == [fÌ‚â¿_(m+1), â€¦, fÌ‚â¿_(n-1)]
fÌ‚ = [fc[m+2:end]; fc[1:m+1]]

# equivalent to fÌ‚â¿_(-m)*exp(-im*m*Î¸) + â€¦Â + fÌ‚â¿_(m)*exp(im*m*Î¸)
fâ‚™ = Î¸ -> transpose([exp(im*k*Î¸) for k=-m:m]) * fÌ‚

# plotting grid
g = range(0, 2Ï€; length=1000)
plot(abs.(fâ‚™.(g) - f.(g)))
```
Thus we have successfully approximate the function to roughly machine precision.
The magic of the FFT is because it's $O(n \log n)$ we can scale it to very high orders.
Here we plot the Fourier coefficients for a function that requires around 100k
coefficients to resolve:
```julia
f = Î¸ -> exp(sin(Î¸))/(1+1e6cos(Î¸)^2)
n = 100_001
m = nÃ·2
# evenly spaced points from 0:2Ï€, dropping last node
Î¸ = range(0, 2Ï€; length=n+1)[1:end-1]

# fft returns discrete Fourier coefficients n*[fÌ‚â¿_0, â€¦, fÌ‚â¿_(n-1)]
fc = fft(f.(Î¸))/n


# We reorder using [fÌ‚â¿_(-m), â€¦, fÌ‚â¿_(-1)] == [fÌ‚â¿_(n-m), â€¦, fÌ‚â¿_(n-1)]
#  == [fÌ‚â¿_(m+1), â€¦, fÌ‚â¿_(n-1)]
fÌ‚ = [fc[m+2:end]; fc[1:m+1]]

plot(abs.(fc); yscale=:log10, legend=:bottomright, label="default")
plot!(abs.(fÌ‚); yscale=:log10, label="reordered")
```


